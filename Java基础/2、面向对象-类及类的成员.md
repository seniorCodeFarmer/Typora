## 1、属性

### 1.1、属性（成员变量）和局部变量

#### 1.1.1、相同点

- 定义变量的格式：数据类型 变量名 = 变量值

- 先声明，后使用

- 变量都有其对应的作用域




#### 1.1.2、不同点

在类中声明的位置的不同

- 属性：直接定义在类的一对{}内
- 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量

关于权限修饰符的不同

- 属性：可以在声明属性时，指明其权限，使用权限修饰符。
- 常用的权限修饰符：private、public、缺省、protected --->封装性
- 局部变量：不可以使用权限修饰符。

默认初始化值的情况：

- 属性：类的属性，根据其类型，都有默认初始化值。
  - 整型（byte、short、int、long）：0
  - 浮点型（float、double）：0.0
  - 字符型（char）：0 （或'\u0000'）
  - 布尔型（boolean）：false
  - 引用数据类型（类、数组、接口）：null

![image-20230727200719184](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230727200719184.png)

- 局部变量：没有默认初始化值，意味着，我们在调用局部变量之前，一定要显式赋值。

- 特别地：形参在调用时，我们赋值即可。



### 1.2、属性赋值的先后顺序

- 默认初始化 -- 显式初始化 -- 构造器中初始化 -- 通过“对象.方法”或“对象.属性”的方式赋值



### 1.3、对象数组的内存解析

![image-20230727201435179](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230727201435179.png)



## 2、方法

### 2.1、方法的声明

```java
权限修饰符 返回值类型 方法名(形参列表){
    方法体
}
```



### 2.2、**return关键字的使用**

- 作用范围：使用在方法体中

- 作用：结束方法；针对于有返回值类型的方法，使用“return 数据”方法返回所要的数据

- 注意点：return关键字后面不可以声明执行语句




### 2.3、使用

- 可以在方法中调用当前类的属性或方法

- 方法中不可以定义方法




### 2.4、方法的重载

- 重载的概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可

- 重载的特点：与返回值类型无关，只看参数列表，且参数列表必须不同（参数个数或者参数类型），调用时根据方法参数列表的不同来区别

- 什么时候用到重载：
  - 方法背后体现的就是功能，当功能一样，只是外部因素（参数）有差异，则考虑使用方法的重载



### 2.5、可变个数的形参

- javaSE5.0中提供了Varargs（variable number of arguments）机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。

- JDK5.0之前：采用数组形参来定义方法，传入多个同一类型变量


```java
public static void test(int a,String[] books);
```

- JDK5.0之后：采用可变个数形参来定义方法，传入多个统一类型变量


```java
public static void test(int a，String...books);
```

**说明：**

- 声明格式：方法名(参数的类型名 ...参数名)
- 可变参数：方法参数部分指定类型的参数个数是可变多个 
- 可变参数方法的使用与方法参数部分使用数组是一致的
- 方法的参数部分有可变形参，需要放在形参声明的最后
- 在一个方法的形参位置，最多只能声明一个可变个数参数



### 2.6、方法参数的值传递机制

- 形参：方法声明时的参数

- 实参：方法调用时实际传递给形参的数据

- java里方法的参数传递方式只有一种：值传递。即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。
  - 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参
  - 形参是引用数据类型：将实参引用数据类型变量的“地址值”copy一份传递给形参

示例：

```java
public class TestInstance {
     public static void main(String[] args) {
         TestInstance test = new TestInstance();
         test.first();
     }
     
     public void first() {
         int i = 5;
         Value v  = new Value();
         v.i = 25;
         secoud(v,i);
         System.out.println(v.i);
     }
     
     public void secoud(Value v,int i) {
         i = 0;
         v.i = 20;
         Value val = new Value();
         v = val;
         System.out.println(v.i + " " + i);
     }
}
class Value{
     int i = 15;
}

输出结果为：15,0
           20
```

![image-20230727204421154](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230727204421154.png)

```java
int[] arr = new int[]{1,2,3};
System.out.println(arr);//地址值

char[] arr1 = new char[]{'a','b','c'};
System.out.println(arr1); //abc
```



## 3、构造器

### 3.1、特征：

- 具有与类相同的名称

- 它不声明返回值类型

- 不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值




### 3.2、构造器的作用

- 创建对象

- 初始化对象的信息




### 3.3、分类

- 隐式无参构造器（系统默认提供）

- 显式定义一个或多个构造器（有参、无参）

- 注意：

  - Java语言中，每个类都至少有一个构造器

  - 默认构造器的修饰符与所属类的修饰符一致

  - 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器

  - 一个类中可以创建多个重载的构造器


```java
定义构造器的格式：权限修饰符 类名(形参列表){}
```



### 3.4、JavaBean

- JavaBean是一种Java语言写成的可重用组件，所谓JavaBean，是指符合如下标准的Java类

  - 类是公共的

  - 有一个无参的公共的构造器

  - 有属性，且有对应的get、set方法

- 
  用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。




### 3.5、UML类图

![image-20230727213259029](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230727213259029.png)



## 4、代码块

### 4.1、介绍

- 代码块的作用：用来初始化类、对象
- 代码块如果有修饰的话，只能使用static
- 分类：静态代码块、非静态代码块



### 4.2、使用

#### 4.2.1、静态代码块（使用Static修饰）

- 内部可以有输出语句

- 随着类的加载而执行此类代码块，而且只执行一次（不管创建了多少个对象，因为类在内存中只会存在一份）

- 可以对类的属性、类的声明进行初始化操作

- 注意：

- - 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
  - 静态代码块的执行要优先于非静态代码块
  - 静态代码块中只能调用静态的属性、静态的方法，不能调用非静态的结构

- 使用场景

- - 在某个程序执行之前，将先要做的初始化工作放到静态代码块中完成



#### 4.2.2、非静态代码块

- 内部可以有输出语句

- 随着对象的创建而执行，而且每创建一个对象就执行一次

- 作用：可以在创建对象时，对对象的属性等进行初始化

- 注意：

- - 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行 
  - 内部可以调用静态的属性、静态的方法、非静态的属性、非静态的方法



#### 4.2.3、对属性可以进行赋值的位置

- 默认初始化
- 显式初始化
- 在代码块中赋值
- 构造器初始化
- 有了对象以后可以通过“对象.属性”和“对象.方法”进行赋值





## 5、内部类

### 5.1、概述

- 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务那么整个内部的完整结构最好使用内部类
- Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类
- 例如：人和大脑，大脑作为一个完整结构可以声明成一个内部类



### 5.2、分类

#### 5.2.1、成员内部类（静态、非静态）

成员内部类作为类的成员的角色

- 和外部类不同，内部类还可以声明为private或protected
- 可调用外部类的结构
- 可以被static修饰
- 可以被4种不同的权限修饰符修饰
- 静态内部类的作用域类似于静态变量，类加载就存在，可以在静态的内部类中访问类的静态资源（属性、方法）

成员内部类作为类的角色

- 类内部可以定义属性、方法、构造器等结构
- 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承
- 可以被abstract修饰，不能实例化，可以被其他内部类继承
- 编译生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）



#### 5.2.2、局部内部类（方法内、代码块内、构造器内）

声明局部内部类

```java
class 外部类{
    方法(){
        class局部内部类{
        }
    }
    {
        class局部内部类{
        }
    }
}
```

使用局部内部类

- 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类
- 但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型

特点：

- 内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。
- 局部内部类可以使用外部类的成员，包括私有的。
- 局部内部类可以使用外部方法的局部变量，但是此局部变量必须是final的，由局部内部类和局部变量的声明周期不同所致。
- 局部内部类和局部变量地位类似，不能使用public、protected、缺省、private修饰。
- 局部内部类不能使用static修饰，因此也不能包含静态成员。



#### 5.2.3、匿名内部类

匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。

格式：

```java
new 父类构造器(实参列表) | 实现接口(){
    //匿名内部类的类体部分
}
```

匿名内部类的特点：

- 匿名内部类必须继承父类或实现接口
- 匿名内部类只能有一个对象
- 匿名内部类对象只能使用多态形式引用
- 匿名类是对原类的继承，同时还创建实例{}就是继承之后的类体，类体中可以使用所有类的语法
- 匿名类中不能写构造器，匿名类可以继承抽象类或者实现接口，必须要提供抽象方法的重写

```java
interface A{
    public abstract void fun1();
}
public class Outer{
    public static void main(String[] args) {
        new Outer().callInner(new A(){
            //接口是不能new但此处比较特殊是子类对象实现接口，只不过没有为对象取名
            public void fun1() {
                System.out.printIn("implement for fun1");
            }
        });//两步写成一步了
    }
    public void calllnner(A a) {
        a.fun1();
    }
}
```



> 注：
>
> - 最重要一点：静态的方法、代码块等不能使用非静态的方法。 不能从静态上下文引用非静态方法。
> - 非静态成员内部类中的声明的成员不能声明为static的，只有在外部类或static的成员内部类中才可以声明static成员。（在语言级别'11'中不支持非静态内部类中的静态声明）
> - 非静态的成员内部类中的方法可以调用外部类中静态方法。
> - 外部类访问成员内部类的成员，需要“内部类.成员”（这种情况适用于静态内部类的静态变量）或“内部类对象.成员”的方式
> - 成员内部类可以直接使用外部类的所有成员，包括私有的数据（站在成员内部类作为类的成员的角度理解）
> - 当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的
> - 外部类给内部类提供命名空间
> - 内部类的实例必须要依托外部内的实例
> - 关注如下的3个问题
>   - 如何实例化成员内部类的对象
>   - 如何在成员内部类中区分调用外部类的结构
>   - 开发中局部内部类的使用 见《InnerClassTest1.java》

- 

#### 5.24、代码示例

```java
public class InnerClassTest {
    public static void main(String[] args) {

        //创建Dog实例(静态的成员内部类):
        Person.Dog dog = new Person.Dog();
        dog.show(); // 卡拉是条狗
        //创建Bird实例(非静态的成员内部类):
        //       Person.Bird bird = new Person.Bird();//错误的
        Person p = new Person();
        Person.Bird bird = p.new Bird();
        bird.sing();

        System.out.println();

        bird.display("黄鹂");
    }
}
class Person{
    String name = "小明";
    int age;

    public void eat(){
        System.out.println("人：吃饭");
    }

    public static void sleep() {
        System.out.println("睡觉");
    }

    //静态成员内部类
    static class Dog{
        String name;
        int age;

        public void show(){
            System.out.println("卡拉是条狗");
            //            eat();
        }
    }
    //非静态成员内部类
    class Bird{
        String name = "杜鹃";

        public Bird(){
        }
        public void sing(){
            System.out.println("我是一只小小鸟");
            Person.this.eat();//调用外部类的非静态方法
            eat(); //调用外部类的非静态方法
            System.out.println(age);
            sleep();
        }


        public void display(String name){
            System.out.println(name);//方法的形参
            System.out.println(this.name);//内部类的属性
            System.out.println(Person.this.name);//外部类的属性
        }
    }
    public void method(){
        //局部内部类
        class AA{
        }
    }
    {
        //局部内部类
        class BB{
        }
    }
    public Person(){
        //局部内部类
        class CC{
        }
    }
}
```







