## 1、Java集合框架

### 1.1、概述

面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。但使用Array存储对象方面具有一些弊端，而Java集合就像一种容器，可以动态地把多个对象的引用放入容器中。此时的存储，主要是指内存层面的存储，不涉及到持久化的存储(.txt,.jpg,.avi,数据库中)



#### 1.1.1、数组的特点与弊端

数组在内存存储方面的特点

- 数组初始化之后，长度就确定了
- 数组声明的类型，就决定了进行元素初始化时的类型，就只能操作指定类型的数据了

数组在存储数据方面的弊端

- 数组初始化以后，长度就不可变了，不便于扩展
- 数组中提供的属性和方法少，不便于进行添加、删除、插入的操作，且效率不高。同时无法直接获取存储元素的个数
- 数组存储的数据是有序的、可以重复的。对于无序、不可重复的需求，不能满足



#### 1.1.2、集合的使用场景

Java集合可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。

![image-20230827213206873](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230827213206873.png)



### 1.2、Collection和Map两种体系

Collection接口：单列数据，定义了存取一组对象的方法的集合

- List：元素有序、可重复的集合 **“动态数组”**
- Set：元素无序、不可重复的集合

Map接口：双列数据，保存具有映射关系“key-value对”的集合



### 1.3、Collection接口继承树

![image-20230322081011130](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322081011130.png)



### 1.4、Map接口继承树

![image-20230322081045159](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322081045159.png)



## 2、Collection接口

### 2.1、概述

- Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合

- JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）实现

- 在Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理，在JDK5.0增加了泛型以后，java集合可以记住容器中对象的数据类型




### 2.2、Collection接口中的方法

- 添加


~~~java
add(Object obj) // 将元素obj添加到集合中（自动装箱）

addAll(Collection coll) // 将集合coll添加到调用此方法的集合中，Set调用会过滤掉重复值
~~~

- 获取有效元素的个数


~~~java
int size()
~~~

- 清空集合


~~~java
void clear()
~~~

- 判断是否是空集合


~~~java
boolean isEmpty()
~~~

- 判断是否包含某个元素 


~~~java
boolean contains(Object obj) // 是通过obj对象所在类的equals方法来判断是否是相同内容（判断内容，需要重写元素obj对象所在类的equals方法）。

boolean containsAll(Collection c) // 判断形参c中的所有元素是否都存在于当前集合中（判断当前集合是否包含集合c的全部元素）。也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。
~~~

- 移除


~~~Java
boolean remove(Object obj) // 通过元素的equals方法判断是否是要删除的那个元素，只会删除找到的第一个元素。

boolean removeAll(Collection coll) // 取当前集合的差集，将当前集合中与coll集合中元素相同的元素删除，并返回是否成功。
~~~

- 取两个集合的交集


~~~java 
boolean retainAll(Collection c) // 通过equals方法判断，并把交集的结果存在当前集合中不影响集合c。
~~~

- 集合是否相等 


~~~java 
boolean equals(Object obj) // 要想返回true，需要当前集合和形参集合的元素都相同。
~~~

- 转成对象数组


~~~java 
Object[] toArray()
~~~

- 获取集合对象的哈希值


~~~java
hashCode()
~~~

- 遍历


~~~java
iterator() // 返回迭代器对象，用于集合遍历
~~~

- 数组转换成集合


~~~java 
Arrays.asList(可变形参)
~~~

~~~java
public void test1(){
    Collection coll = new ArrayList();

    //add(Object e):将元素e添加到集合coll中
    coll.add("AA");
    coll.add("BB");
    coll.add(123);//自动装箱
    coll.add(new Date());

    //size():获取添加的元素的个数
    System.out.println(coll.size());//4

    //addAll(Collection coll1):将coll1集合中的元素添加到当前的集合中
    Collection coll1 = new ArrayList();
    coll1.add(456);
    coll1.add("CC");
    coll.addAll(coll1);

    System.out.println(coll.size());//6
    System.out.println(coll);

    //clear():清空集合元素
    coll.clear();

    //isEmpty():判断当前集合是否为空，并不等同与Null，集合为Null,意味着声明了集合变量，但并未在内存中开辟空间，集合为空，则是在内存中开辟了空间，但并未存储值
    System.out.println(coll.isEmpty());
}

public void test1(){
    Collection coll = new ArrayList();
    coll.add(123);
    coll.add(456);
    //        Person p = new Person("Jerry",20);
    //        coll.add(p);
    coll.add(new Person("Jerry",20));
    coll.add(new String("Tom"));
    coll.add(false);

    //1.contains(Object obj):判断当前集合中是否包含obj
    //我们在判断时会调用obj对象所在类的equals()。
    boolean contains = coll.contains(123);
    System.out.println(contains);
    System.out.println(coll.contains(new String("Tom")));
    //        System.out.println(coll.contains(p));//true
    System.out.println(coll.contains(new Person("Jerry",20)));//false -->true

    //2.containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在于当前集合中。
    Collection coll1 = Arrays.asList(123,4567);
    System.out.println(coll.containsAll(coll1));
}

public void test2(){
    //3.remove(Object obj):从当前集合中移除obj元素。
    Collection coll = new ArrayList();
    coll.add(123);
    coll.add(456);
    coll.add(new Person("Jerry",20));
    coll.add(new String("Tom"));
    coll.add(false);

    coll.remove(1234);
    System.out.println(coll);

    coll.remove(new Person("Jerry",20));//true
    System.out.println(coll);

    //4. removeAll(Collection coll1):差集：从当前集合中移除与coll1中所有相同的元素。
    Collection coll1 = Arrays.asList(123,456);
    coll.removeAll(coll1);
    System.out.println(coll);
}

public void test3(){
    Collection coll = new ArrayList();
    coll.add(123);
    coll.add(456);
    coll.add(new Person("Jerry",20));
    coll.add(new String("Tom"));
    coll.add(false);

    //5.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合
    //        Collection coll1 = Arrays.asList(123,456,789);
    //        coll.retainAll(coll1);
    //        System.out.println(coll);

    //6.equals(Object obj):要想返回true，需要当前集合和形参集合的元素都相同。
    Collection coll1 = new ArrayList();
    coll1.add(456);
    coll1.add(123);
    coll1.add(new Person("Jerry",20));
    coll1.add(new String("Tom"));
    coll1.add(false);

    System.out.println(coll.equals(coll1));
}

public void test4(){
    Collection coll = new ArrayList();
    coll.add(123);
    coll.add(456);
    coll.add(new Person("Jerry",20));
    coll.add(new String("Tom"));
    coll.add(false);

    //7.hashCode():返回当前对象的哈希值
    System.out.println(coll.hashCode());

    //8.集合 --->数组：toArray()
    Object[] arr = coll.toArray();
    for(int i = 0;i < arr.length;i++){
        System.out.println(arr[i]);
    }

    //拓展：数组 --->集合:调用Arrays类的静态方法asList()
    List<String> list = Arrays.asList(new String[]{"AA", "BB", "CC"});
    System.out.println(list);

    List arr1 = Arrays.asList(new int[]{123, 456});//一个元素
    System.out.println(arr1.size());//1

    List arr2 = Arrays.asList(new Integer[]{123, 456});//两个元素
    System.out.println(arr2.size());//2

    //9.iterator():返回Iterator接口的实例，用于遍历集合元素。放在IteratorTest.java中测试
}
~~~



> 注：
>
> 面试题：向List中插入1、2、3、4、5、6 六个Integer类型元素，remove(1)、remove(2)、remove(3)后还剩什么？
>
> 1,5,6



### 2.3、Iterator迭代器接口

#### 2.3.1、使用Iterator接口遍历集合元素

- Iterator对象称为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素。
- GOF给迭代器模式的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不暴露该对象的内部细节。迭代器模式，就是为容器而生。
- Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。
- Iterator仅用于遍历集合，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。
- 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。



#### 2.3.2、Iterator接口的方法

- hasNext()和next()方法搭配使用


```java
////hasNext():判断是否还有下一个元素
while(iterator.hasNext()){
    //next():指针下移;将下移以后集合位置上的元素返回
    System.out.println(iterator.next());
}
```

- 迭代器的执行原理

  - 当返回一个Iterator对象时，就有一个指针游标指向集合第一个元素的前一个位置，当Iterator调用hasNext()后，判断指针指向的位置的下一个位置是否有元素，如果有则进入循环，调用next()指针下移，返回下移后指向的位置上的元素


- Iterator接口的remove()方法：可以在遍历的时候，删除集合元素。此方法不同于集合调用remove()

  - Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove()

  - 如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException


![image-20230322082222943](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322082222943.png)

- 使用foreach循环遍历集合元素

  - Java5.0提供了foreach循环迭代访问Collection集合和数组

  - 遍历操作不需获取Collection或数组的长度，无需使用索引访问元素

  - 遍历集合的底层调用Iterator完成操作

  - foreach还可以用来遍历数组


```java
public void test3(){
    Collection coll = new ArrayList();
    coll.add(123);
    coll.add(456);
    coll.add(new Person("Jerry",20));
    coll.add(new String("Tom"));
    coll.add(false);

    //删除集合中"Tom"
    Iterator iterator = coll.iterator();
    while (iterator.hasNext()){
        Object obj = iterator.next();
        if("Tom".equals(obj)){
            iterator.remove();
        }
    }
    //遍历集合
    iterator = coll.iterator();
    while (iterator.hasNext()){
        System.out.println(iterator.next());
    }
}
```



### 2.4、Collection的子接口之一：List接口

#### 2.4.1、概述

- 鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组。

- List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。

- List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。

- JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector

  - ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储

  - LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储

  - Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储



#### 2.4.2、List接口方法

List除了从Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法：

~~~java 
void add(int index,Object ele) // 在index位置插入ele元素，index后面的元素后移
~~~

~~~java 
boolean addAll(int index,Collection eles) // 从index位置开始将eles中的所有元素添加进来
~~~

~~~java 
Object get(int index) // 获取指定index位置的元素
~~~

~~~java
int indexOf(Object obj) // 返回obj在集合中首次出现的位置，如果不存在，返回-1
~~~

~~~java 
int lastIndexOf(Object obj) // 返回obj在当前集合中末次出现的位置
~~~

~~~java
Object remove(int index) // 移除指定index位置的元素，并返回此元素（重载方法）
~~~

~~~java 
Object set(int index,Object ele) // 设置指定index位置的元素为ele，返回被替换掉的元素
~~~

~~~java 
List subList(int fromIndex,int toIndex) // 返回从fromIndex到toIndex位置的子集合，左闭右开的子集合
~~~



#### 2.4.3、总结常用方法

- 增：add(Object obj)
- 删：remove(int index) / remove(Object obj)
- 改：set(int index,Object ele)
- 查：get(int index)
- 插：add(int index,Object ele)
- 长度：size()
- 遍历：Iterator迭代器方法、增强for循环、普通循环





#### 2.4.4、List实现类之一：ArrayList

##### 1、概述

- ArrayList是List接口的典型实现类、主要实现类，本质上，ArrayList是对象引用的一个“变长”数组

- ArrayList在JDK1.8之前与之后的实现区别？

  - JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组

  - JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个初始容量为10的数组

- 如果发生扩容，则扩容为原来的1.5倍

> 注：
>
> Arrays.asList(...)方法返回List集合，既不是ArrayList实例，也不是Vector实例，Arrays.asList(...)返回值是一个固定长度的List类型的集合



##### 2、ArrayList源码分析：jdk7

```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * Shared empty array instance used for empty instances.
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

    /**
     * Shared empty array instance used for default sized empty instances. We
     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
     * first element is added.
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     * The array buffer into which the elements of the ArrayList are stored.
     * The capacity of the ArrayList is the length of this array buffer. Any
     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
     * will be expanded to DEFAULT_CAPACITY when the first element is added.
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * The size of the ArrayList (the number of elements it contains).
     *
     * @serial
     */
    private int size;
}


ArrayList list = new ArrayList()；// 底层创建了长度是10的Object[]数组elementData
list.add(123);//elementData[0] = new Integer(123)
...
list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容，默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中
```

结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)，减少底层频繁扩容数组，提高效率



##### 3、ArrayList源码分析：jdk8

```java
ArrayList list = new ArrayList();//底层Object[]数组elementData初始化为{}，并没有创建长度为10的数组
list.add(123);//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData[0]
... 后续添加和扩容操作与jdk7一样
```

结论：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存



#### 2.4.5、List实现类之二：LinkedList

- 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高

- 新增方法：

  - void addFirst(Object obj)

  - void addLast(Object obj)

  - Object getFirst()

  - Object getLast()

  - Object removeFirst()

  - Object removeLast()

- LinkedList：双向链表，内部没有声明数组，而是定义了内部类Node，作为LinkedList中保存数据的基本结构，并定义了Node类型的first和last，用于记录首末元素。Node除了保存数据，还定义了两个变量：

  - prev变量记录前一个元素的位置
  - next变量记录下一个元素的位置

```java
LinkedList list = new LinkedList();内部声明了Node类型的first属性和last属性，默认值为null
list.add(123);//将123封装到Node中，创建了Node对象
其中，Node定义为：体现了LinkedList的双向链表的说法
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

​	

#### 2.4.6、List实现类之三：Vector

- Vector是一个古老的集合，JDK1.0就存在了。大多数操作与ArrayList相同，区别之处在于Vector线程是安全的。

- 在各种list中，最好把 ArrayList 作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。

- Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组在扩容方面，默认扩容为原来数组长度的2倍。




### 2.5、Collection子接口之二：Set接口

#### 2.5.1、概述

- Set 接口是Collection的子接口，Set接口没有提供额外的方法

- Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败

- Set 判断两个对象是否相同不是使用 == 运算符，而是根据equals方法

- Set 存储数据的特点：无序，不可重复




#### 2.5.2、Set接口的实现类

- HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值

- LinkedHashSet：作为HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet

- TreeSet：可以按照添加对象的指定属性，进行排序




#### 2.5.3、理解Set无序和不可重复

##### 1、以HashSet为例说明

- 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的

- 不可重复性：保证添加的元素按照equals()判断时不能返回true，即相同的元素只能添加一个 




##### 2、Set中添加元素的过程

- 以HashSet为例，底层创建数组的时机和ArrayList一样，长度为16

- 向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：

  - 如果此位置上没有其他元素，则元素a添加成功(情况1)

  - 如果此位置上有其他元素b（或以链表形式存在的多个元素），则比较元素a与元素b的hash值

    - 如果hash值不相同，则元素a添加成功(情况2)

    - 如果hash值相同，进而需要调用元素a所在类的equals()方法，如果元素b以链表形式存在的多个元素，则遍历比较链表上的每一个值

      - equals()返回true，元素a添加失败

      - equals()返回false，元素a添加成功(情况3)

- 对于添加成功的情况而言：元素a与已经存在指定索引位置上的数据以链表的方式存储

  - jdk7中：元素a放到数组中，指向原来的元素

  - jdk8中：原来的元素在数组中，指向元素a


![image-20230322090059733](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322090059733.png)



#### 2.5.4、Set实现类之一：HashSet

##### 1、介绍与特点

- HashSet是Set接口的典型实现，大多数时候使用Set集合时都是用这个实现类 

- HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能

- HashSet具有以下特点：

  - 不能保证元素的排列顺序

  - HashSet是线程不安全的

  - 集合元素可以是null

  - 底层是数组+链表

  - HashSet的底层是HashMap


- HashSet集合判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals方法的返回值也相等

- 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码(哈希值)”

- 添加元素，元素会被添加在Map的Key位置，而Value值是一个Object对象


```java
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable {
    static final long serialVersionUID = -5024744406713321676L;

    private transient HashMap<E,Object> map;

    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();

    /**
     * Constructs a new, empty set; the backing <tt>HashMap</tt> instance has
     * default initial capacity (16) and load factor (0.75).
     */
    public HashSet() {
        map = new HashMap<>();
    }
    
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
}
```



##### 2、向HashSet中添加元素的过程

- 当向HashSet集合中存入（移除）一个元素时，HashSet会先调用该对象的hashCode()方法来得到该对象的hash值，通过某种散列函数决定该对象在HashSet底层数组中的存储位置（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素越是散列分布，该散列函数设计的越好）

- 如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接

- 向Set中添加的数据，其所在类一定要重写hashCode()和equals()，且尽可能保持一致性

- 如果两个元素的equals()方法返回true，但它们的hashCode()返回值不相等，HashSet将会把它们存储到不同的位置，但依然可以添加成功




##### 3、重写equals()方法的原则

- 当一个类有自己特有的“逻辑相等”概念，当改写equals()的时候， 总是要改写hashCode()，根据一个类的equals方法(改写后)，两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。因此，违反了“相等的对象必须具有相等的散列码”。

- 结论：复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。




#### 2.5.5、HashSet的实现类：LinkedHashSet

- LinkedHashSet是HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历 

- LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的

- LinkedHashSet插入性能略低于HashSet，但在迭代访问Set里的全部元素时有很好的性能

- LinkedHashSet不允许集合元素重复

- LinkedHashSet底层结构：与HashSet相似，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据的地址

  - 优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet

- 
  LinkedHashSet底层是LinkedHashMap


~~~Java
public class LinkedHashSet<E>
    extends HashSet<E>
    implements Set<E>, Cloneable, java.io.Serializable {

    private static final long serialVersionUID = -2851667679971038690L;

    /**
     * Constructs a new, empty linked hash set with the specified initial
     * capacity and load factor.
     *
     * @param      initialCapacity the initial capacity of the linked hash set
     * @param      loadFactor      the load factor of the linked hash set
     * @throws     IllegalArgumentException  if the initial capacity is less
     *               than zero, or if the load factor is nonpositive
     */
    public LinkedHashSet(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor, true);
    }

    /**
     * Constructs a new, empty linked hash set with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param   initialCapacity   the initial capacity of the LinkedHashSet
     * @throws  IllegalArgumentException if the initial capacity is less
     *              than zero
     */
    public LinkedHashSet(int initialCapacity) {
        super(initialCapacity, .75f, true);
    }
    
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap<>(initialCapacity, loadFactor);
    }

    /**
     * Constructs a new, empty linked hash set with the default initial
     * capacity (16) and load factor (0.75).
     */
    public LinkedHashSet() {
        super(16, .75f, true);
    }

    /**
     * Constructs a new linked hash set with the same elements as the
     * specified collection.  The linked hash set is created with an initial
     * capacity sufficient to hold the elements in the specified collection
     * and the default load factor (0.75).
     *
     * @param c  the collection whose elements are to be placed into
     *           this set
     * @throws NullPointerException if the specified collection is null
     */
    public LinkedHashSet(Collection<? extends E> c) {
        super(Math.max(2*c.size(), 11), .75f, true);
        addAll(c);
    }
}
~~~





#### 2.5.6、Set实现类之三：TreeSet

##### 1、TreeSet特点

- TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态（从小到大）

- 向TreeSet中添加的数据，要求是相同类的对象

- 可以按照添加对象的指定属性，进行排序

- TreeSet底层使用红黑树结构存储数据

- 有序，查询速度比List快




##### 2、TreeSet两种排序方式

自然排序(Comparable接口)和定制排序(Comparator接口)。默认情况下TreeSet采用自然排序

自然排序：

- 自然排序中，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()。TreeSet会调用集合元素的comparaTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序（默认情况）排列
- 如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口
  - 实现Comparable的类必须实现compareTo(Object obj)方法，两个对象即通过compareTo(Object obj)方法的返回值来比较大小
  - 向TreeSet中添加元素时，只有第一个元素无需比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较
  - 因为只有相同类的两个实例才会比较大小，所以向TreeSet中添加的应该是同一个类的对象
  - 对于TreeSet集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过compareTo(Objectobj)方法比较返回值为0
  - 当需要把一个对象放入TreeSet中，重写该对象对应的equals()方法时，应保证该方法与compareTo(Object obj)方法有一致的结果：如果两个对象通过equals()方法比较返回true，则通过compareTo(Object obj)方法比较应返回0，否则，让人难以理解
  - Comparable的典型实现
    - BigDecimal、BigInteger以及所有的数值型对应的包装类：按它们对应的数值大小进行比较
    - Character：按字符的Unicode值来比较
    - Boolean：true对应的包装类实例大于false对应的包装类实例
    - String：按字符串中字符的Unicode值进行比较
    - Date、Time：后边的时间、日期比前面的时间、日期大

```java
//按照姓名从大到小排列,年龄从小到大排列
    @Override
    public int compareTo(Object o) {
        if(o instanceof User){
            User user = (User)o;
//            return -this.name.compareTo(user.name);
            int compare = -this.name.compareTo(user.name);
            if(compare != 0){
                return compare;
            }else{
                return Integer.compare(this.age,user.age);
            }
        }else{
            throw new RuntimeException("输入的类型不匹配");
        }
    }
```



定制排序：

- 定制排序中，比较两个对象是否相同的标准为：compare()返回0，不再是equals()
- TreeSet的自然排序要求元素所属的类实现Compareble接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序（默认情况）的方式排列元素或希望按照其他属性大小进行排序，则考虑使用定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法
- 利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2如果返回0，表示相等；返回负整数，表示o1小于o2
- 要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器
- 此时，仍然只能向TreeSet中添加相同类型的对象，否则发生ClassCastException异常
- 使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0

```java
public void test2(){
        Comparator com = new Comparator() {
            //按照年龄从小到大排列
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof User && o2 instanceof User){
                    User u1 = (User)o1;
                    User u2 = (User)o2;
                    return Integer.compare(u1.getAge(),u2.getAge());
                }else{
                    throw new RuntimeException("输入的数据类型不匹配");
                }
            }
        };

        TreeSet set = new TreeSet(com);
        set.add(new User("Tom",12));
        set.add(new User("Jerry",32));
        set.add(new User("Jim",2));
        set.add(new User("Mike",65));
        set.add(new User("Mary",33));
        set.add(new User("Jack",33));
        set.add(new User("Jack",56));

        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
```

![image-20230322093429433](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322093429433.png)



> 注：
>
> 在List内去除重复数字值，要求尽量简单。
>
> ```java
> public static List duplicateList(List list) {
>        HashSet set = new HashSet();
>        set.addAll(list);
>        return new ArrayList(set);
> }
> public static void main(String[] args) {
>        List list = new ArrayList() ;
>        list.add(new Integer(1));
>        list.add(new Integer(2));
>        list.add(new Integer(2));
>        list.add(new Integer(4));
>        list.add(new Integer(4));
>        List list2 = duplicateList(list);
>        for (object integer : list2) {
>            System.out.println(integer);
>        }
> }
> ```
>
> ```java
> public void test3(){
>        HashSet set = new HashSet();
>        Person p1 = new Person(1001,"AA");//Person中重写了equals()和hashCode()
>        Person p2 = new Person(1002,"BB");
> 
>        set.add(p1);
>        set.add(p2);
>        System.out.println(set);
> 
>        p1.name = "CC";
>        set.remove(p1); //false 因为remove方法调用了对象的hash方法，计算了对象的hash值，这时p1的hash值已经改变，在集合中找不到p1
>        System.out.println(set);//两个对象BB,CC
>        set.add(new Person(1001,"CC"));
>        System.out.println(set);//三个对象BB，CC，CC 因为CC之前的p1存储的位置是AA的
>        set.add(new Person(1001,"AA"));// 可以链接在存储在AA位置的CC上
>        System.out.println(set);
>    }
> ```









![image-20230322093443096](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322093443096.png)



## 3、Map接口

### 3.1、Map接口概述

- Map与Collection并列存在。用于保存具有映射关系的数据：key-value
- Map中的key和value都可以是任何引用类型的数据



### 3.2、Map中的key-value结构的特点

- Map中的key用Set来存放，无序，且不允许重复，key所在的类需重写hashCode()和equals()方法（以HashMap为例）
- Map中的value是无序的，可重复的，使用Collection存储所有的value，value所在类要重写equals()
- key-value构成了一个Entry对象，entry是无序的、不可重复的，使用Set存储所有的entry 
- 常用String类作为Map的“键”
- key和value之间存在单向一对一关系，即通过指定的key总能找到唯一的、确定的value
- Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map接口使用频率最高的实现类



### 3.3、Map的实现类的结构

![Image](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/Image.png)

![image-20230908144037793](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230908144037793.png)





### 3.4、Map接口常用方法

- 添加、删除、修改操作

~~~Java
Object put(Object key,Object value) // 将指定key-value添加到(或修改)当前map对象中

void putAll(Map m) // 将m中的所有key-value对存放到当前map中

object remove(Object key) // 移除指定key的key-value对，并返回value

void clear() // 清空当前map中的所有数据
~~~

- 元素查询操作

~~~java 
Object get(Object key) // 获取指定key对应的value
    
boolean containsKey(Object key) // 是否包含指定的key

boolean containsValue(Object value) // 是否包含指定的value

int size() // 返回map中key-value对的个数

boolean isEmpty() // 判断当前map是否为空（空并不等同于Null）

boolean equals(Object obj) // 判断当前map和参数对象obj是否相等
~~~

- 元视图操作的方式（对返回的Set和Collection集合可以使用Iterator迭代器和增强for循环）

~~~java 
Set keySet() // 返回所有key构成的Set集合
    
Collection values() // 返回所有value构成的Collection集合
	
Set entrySet() // 返回所有key-value对构成的Set集合
~~~

~~~java 
public void test5(){
    Map map = new HashMap();
    map.put("AA",123);
    map.put(45,1234);
    map.put("BB",56);

    //遍历所有的key集：keySet()
    Set set = map.keySet();
    Iterator iterator = set.iterator();
    while(iterator.hasNext()){
        System.out.println(iterator.next());
    }
    System.out.println();

    //遍历所有的value集：values()
    Collection values = map.values();
    for(Object obj : values){
        System.out.println(obj);
    }
    System.out.println();

    //遍历所有的key-value
    //方式一：entrySet()
    Set entrySet = map.entrySet();
    Iterator iterator1 = entrySet.iterator();
    while (iterator1.hasNext()){
        Object obj = iterator1.next();
        //entrySet集合中的元素都是entry
        Map.Entry entry = (Map.Entry) obj;
        System.out.println(entry.getKey() + "---->" + entry.getValue());

    }
    System.out.println();

    //方式二：
    Set keySet = map.keySet();
    Iterator iterator2 = keySet.iterator();
    while(iterator2.hasNext()){
        Object key = iterator2.next();
        Object value = map.get(key);
        System.out.println(key + "=====" + value);
    }
}
~~~

- 总结：常用方法

~~~Java
添加：Object put(Object key,Object value)
		
删除：Object remove(Object key)
		
修改：Object put(Object key,Object value)
		
查询：Object get(Object key)
	
长度：size()
		
遍历：keySet/value()/entrySet()
~~~



### 3.5、Map的实现类之一：HashMap

#### 3.5.1、HashMap概述

- HashMap是Map接口使用频率最高的实现类。
- 允许使用null键和null值，与HashSet一样，不保证映射的顺序。
- 所有的key构成的集合是Set：无序的、不可重复的。所以，key所在的类需要重写：equals()和hashCode()。
- 所有value构成的集合是Collection：无序的、可以重复的。所以，value所在的类要重写：equals()。
- 一个key-value构成一个entry。
- 所有的entry构成的集合是Set：无序的、不可重复的。
- HashMap判断两个key相等的标准是：两个key通过equals()方法返回true，hashCode()值也相等。
- HashMap判断两个value相等的标准是：两个value通过equals()方法返回true。



#### 3.5.2、HashMap的存储结构（以jdk1.7为例说明）

- HashMap的内部存储结构其实是数组和链表的结合。在实例化以后，底层创建了长度为Capacity(16)的一维数组Entry[] table，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素
- 每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。
- 添加元素的过程：
  - 向HashMap中添加entry1(key,value)，需要首先计算entry1中的key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理后，得到在底层Entry[]数组中要存储的位置i。如果位置i上没有元素则entry1直接添加成功。如果位置i上已经存在了entry2(或还有链表存在的entry3,entry4)，则需要通过循环的方法，依次比较entry1中的key和其他的entry中的key。如果彼此hash值不同，则直接添加成功。如果hash值相同，继续比较是否equals。如果返回true，则使用entry1的value去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都为false，则entry1仍可添加成功，entry1指向原有的entry元素。

- HashMap的扩容
  - 当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在HashMap数组扩容以后，**最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。**当HashMap中的元素个数超过数组大小（数组总大小length，不是数组中个数size） \* loadFactor时就会进行数组扩容，loadFactor的默认值（DEFAULT_LOAD_FACTOR）为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小（DEFAULT_INITIAL_CAPACITY）为16，那么当HashMap中元素个数超过16 \* 0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2 * 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果已经预知HashMap中的元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。

~~~Java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {

    private static final long serialVersionUID = 362498820763181265L;

    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

    static final int MAXIMUM_CAPACITY = 1 << 30;

    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    static final int TREEIFY_THRESHOLD = 8;

    static final int UNTREEIFY_THRESHOLD = 6;

    static final int MIN_TREEIFY_CAPACITY = 64;

    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
    
    transient Node<K,V>[] table;
}
~~~



#### 3.5.3、HashMap 底层实现原理（以JDK1.7为例说明）

~~~Java
HashMap map = new HashMap();
// 在实例化以后，底层创建了长度是16的一维数组Entry[] table（数组名）
// ...已经执行过多次put
map.pub(key1,value1)
~~~

- 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry[]数组中的存放位置。
  - 如果此位置上的数据为空，此时的key1-value1添加成功（情况1）。
  - 如果此位置上的数据不为空（意味着此位置上存在一个或多个数据（以链表形式存在）），比较key1和已经存在的一个或多个数据的哈希值。
    - 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。
    - 如果key1的哈希值和已经存在的某一个数据（key2-value2）的哈希值相同，继续比较，调用key1所在类的equals(key2)方法比较（比较key值）。
      - 如果equals()返回false：此时key1-value1添加成功（情况3）。
      - 如果equals()返回true：使用value1替换value2，并将被替换的元素（value2）返回。

- 关于情况2和情况3：此时的key1-value1和原来的数据以链表的方式存储。
- 在不断地添加过程中，会涉及到扩容问题，当超出临界值（且要存的位置非空时）默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。
- jdk8相较于jdk7在底层实现方面的不同：
  - new HashMap()：底层没有创建一个长度为16的数组。
  - jdk8底层数组是：Node[]，而非Entry[]。
  - 首次调用put()方法时，底层创建长度为16的数组。
  - jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树，当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8且当前数组长度超过64，此时索引位置上的所有数据的链表改为使用红黑树存储。如果之后红黑树长度小于6，还会重新转成链表。



#### 3.5.4、HashMap源码中的重要常量

- DEFAULT_ INITIAL_CAPACITY ：HashMap的默认容量，16
- MAXIMUM_ CAPACITY ：HashMap的最大支持容量，2^30
- DEFAULT_ LOAD_ FACTOR：HashMap的默认加载因子
- TREEIFY_ THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树
- UNTREEIFY_ THRESHOLD： Bucket中红黑树存储的Node小于该默认值，转化为链表
- MIN_ TREEIFY_ CAPACITY：桶中的Node被树化时最小的hash表容量。 (当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_ TREEIFY_ CAPACITY时，此时应执行resize扩容操作，这个MIN_ TREEIFY_ CAPACITY的值至少是TREEIFY_THRESHOLD的4倍)
- table：存储元素的数组，总是2的n次幂
- entrySet：存储具体元素的集
- size：HashMap中存储的键值对的数量
- modCount：HashMap扩容和结构改变的次数。
- threshold：扩容的临界值=容量*填充因子
- loadFactor：填充因子



### 3.6、Map实现类之二：LinkedHashMap

- LinkedHashMap是HashMap的子类
- 在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序
- 与LinkedHashSet类似，LinkedHashMap可以维护Map的迭代顺序：迭代顺序与key-value对的插入顺序一致（在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素）对于频繁的遍历操作，此类执行效率高于HashMap

~~~Java
public class LinkedHashMap<K,V>
    extends HashMap<K,V>
    implements Map<K,V>
{

    static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }

    private static final long serialVersionUID = 3801124242820219131L;

    transient LinkedHashMap.Entry<K,V> head;

    transient LinkedHashMap.Entry<K,V> tail;

    final boolean accessOrder;
}
~~~



### 3.7、Map的实现类之三：TreeMap

- TreeMap存储Key-Value对时，需要根据key-value对进行排序，TreeMap可以保证所有的key-value对处于有序状态，实现排序遍历

- TreeSet底层使用红黑树结构存储数据![img](data:image/png;base64,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)

- TreeMap的Key的排序

- - 自然排序：TreeMap的所有Key必须实现Comparable接口，而且所有的Key应该是同一个类的对象否则将会抛出ClassCastException
  - 定制排序：创建TreeMap时，传入一个Comparator对象，该对象负责对TreeMap中的所以Key进行排序。此时不需要Map的Key实现Comparable接口

- TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0

~~~Java
public class TreeMapTest {
    //向TreeMap中添加key-value，要求key必须是由同一个类创建的对象
    //因为要按照key进行排序：自然排序 、定制排序
    //自然排序
    @Test
    public void test1(){
        TreeMap map = new TreeMap();
        User u1 = new User("Tom",23);
        User u2 = new User("Jerry",32);
        User u3 = new User("Jack",20);
        User u4 = new User("Rose",18);

        map.put(u1,98);
        map.put(u2,89);
        map.put(u3,76);
        map.put(u4,100);

        Set entrySet = map.entrySet();
        Iterator iterator1 = entrySet.iterator();
        while (iterator1.hasNext()){
            Object obj = iterator1.next();
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + "---->" + entry.getValue());
        }
    }

    //定制排序
    @Test
    public void test2(){
        TreeMap map = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof User && o2 instanceof User){
                    User u1 = (User)o1;
                    User u2 = (User)o2;
                    return Integer.compare(u1.getAge(),u2.getAge());
                }
                throw new RuntimeException("输入的类型不匹配！");
            }
        });
        User u1 = new User("Tom",23);
        User u2 = new User("Jerry",32);
        User u3 = new User("Jack",20);
        User u4 = new User("Rose",18);

        map.put(u1,98);
        map.put(u2,89);
        map.put(u3,76);
        map.put(u4,100);

        Set entrySet = map.entrySet();
        Iterator iterator1 = entrySet.iterator();
        while (iterator1.hasNext()){
            Object obj = iterator1.next();
            Map.Entry entry = (Map.Entry) obj;
            System.out.println(entry.getKey() + "---->" + entry.getValue());
        }
    }
}
~~~



### 3.8、Map实现类之四：HashTable

- Hashtable是个古老的Map实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的
- Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用
- 与HashMap不同，Hashtable不允许使用null作为key和value
- 与HashMap一样，Hashtable也不能保证其中key-value对的顺序
- Hashtable判断两个key相等、两个value相等的标准，与HashMap一致
- HashTable底层数组默认初始容量为11，每次扩容为原来的2n+1



### 3.9、Map实现类之五：Properties

- Properties类是Hashtable的子类，该对象用于处理属性配置文件
- 由于配置文件里的key、value都是字符串类型，所以Properties里的key和value都是String类型
- 存取数据是，建议使用setProperty(String key,String value)方法和getProperty(String key)方法

~~~Java
Properties properties = new Properties();

FileInputStream fileInputStream = new FileInputStream("jdbc.properties");
properties.load(fileInputStream);//加载流对应的文件

String name = properties.getProperty("name");
String password = properties.getProperty("password");

System.out.println("name=" + name + ",password=" + password);
~~~



## 4、Collections 工具类

### 4.1、概述

- Collections是一个操作Set、List和Map等集合的工具类
- Collections中提供了一系列静态的方法对集合元素进行排序、查询、修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法
- 排序操作：(均为static方法)
  - reverse(List)：反转 List 中元素的顺序
  - shuffle(List)：对 List 集合元素进行随机排序
  - sort(List)：根据元素的自然顺序对指定List集合元素按升序排序
  - sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序
  - swap(List,int,int)：将指定list集合中的i处元素和j处元素进行交换



### 4.2、Collections 常用方法

- 查找、替换

~~~Java
Object max(Collection) // 根据元素的自然顺序，返回给定集合中的最大元素
 
Object max(Collection,Comparator) // 根据Comparator指定的顺序，返回给定集合中的最大元素

Object min(Collection)
    
Object min(Collection,Comparator)

int frequency(Collection,Object) // 返回指定集合中指定元素的出现次数
	
void copy(List dest,List src) // 将src中的内容复制到dest中
	
boolean replaceAll(List list,Object oldVal,Object newVal) // 使用新值替换List对象的所有旧值
~~~



### 4.3、Collections常用方法：同步控制

- Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题

~~~Java
//返回的list1即为线程安全的List
List list1 = Collections.synchronizedList(list);
~~~

























