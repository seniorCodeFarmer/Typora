## 1、Java集合框架

### 1.1、概述

面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。但使用Array存储对象方面具有一些弊端，而Java集合就像一种容器，可以动态地把多个对象的引用放入容器中。此时的存储，主要是指内存层面的存储，不涉及到持久化的存储(.txt,.jpg,.avi,数据库中)



#### 1.1.1、数组的特点与弊端

数组在内存存储方面的特点

- 数组初始化之后，长度就确定了
- 数组声明的类型，就决定了进行元素初始化时的类型，就只能操作指定类型的数据了

数组在存储数据方面的弊端

- 数组初始化以后，长度就不可变了，不便于扩展
- 数组中提供的属性和方法少，不便于进行添加、删除、插入的操作，且效率不高。同时无法直接获取存储元素的个数
- 数组存储的数据是有序的、可以重复的。对于无序、不可重复的需求，不能满足



#### 1.1.2、集合的使用场景

Java集合可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。

![Image](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/Image.png)



### 1.2、Collection和Map两种体系

Collection接口：单列数据，定义了存取一组对象的方法的集合

- List：元素有序、可重复的集合 **“动态数组”**
- Set：元素无序、不可重复的集合

Map接口：双列数据，保存具有映射关系“key-value对”的集合



### 1.3、Collection接口继承树

![image-20230322081011130](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322081011130.png)



### 1.4、Map接口继承树

![image-20230322081045159](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322081045159.png)



## 2、Collection接口

### 2.1、概述

Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合

JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）实现

在Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理，在JDK5.0增加了泛型以后，java集合可以记住容器中对象的数据类型



### 2.2、Collection接口中的方法

添加

- add(Object obj)：将元素obj添加到集合中（自动装箱）
- addAll(Collection coll)：将集合coll添加到调用此方法的集合中，Set调用会过滤掉重复值

获取有效元素的个数

- int size()

清空集合

- void clear()

是否是空集合

- boolean isEmpty()

是否包含某个元素 

- boolean contains(Object obj)：是通过obj对象所在类的equals方法来判断是否是相同内容（判断内容，需要重写元素obj对象所在类的equals方法）。
- boolean containsAll(Collection c)：判断形参c中的所有元素是否都存在于当前集合中（判断当前集合是否包含集合c的全部元素）。也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。

移除

- boolean remove(Object obj)：通过元素的equals方法判断是否是要删除的那个元素，只会删除找到的第一个元素。
- boolean removeAll(Collection coll)：取当前集合的差集，将当前集合中与coll集合中元素相同的元素删除，并返回是否成功。

取两个集合的交集

- boolean retainAll(Collection c)：通过equals方法判断，并把交集的结果存在当前集合中不影响集合c。

集合是否相等 

- boolean equals(Object obj)：要想返回true，需要当前集合和形参集合的元素都相同。

转成对象数组

- Object[] toArray()

获取集合对象的哈希值

- hashCode()

遍历

- iterator()：返回迭代器对象，用于集合遍历

数组转换成集合

- Arrays.asList(可变形参)



> 注：
>
> 面试题：向List中插入1、2、3、4、5、6 六个Integer类型元素，remove(1)、remove(2)、remove(3)后还剩什么？
>
> 1,5,6



### 2.3、Iterator迭代器接口

#### 2.3.1、使用Iterator接口遍历集合元素

- Iterator对象称为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素。
- GOF给迭代器模式的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不暴露该对象的内部细节。迭代器模式，就是为容器而生。
- Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。
- Iterator仅用于遍历集合，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。
- 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。



#### 2.3.2、Iterator接口的方法

hasNext()和next()方法搭配使用

```java
////hasNext():判断是否还有下一个元素
        while(iterator.hasNext()){
            //next():指针下移;将下移以后集合位置上的元素返回
            System.out.println(iterator.next());
        }
```

迭代器的执行原理

- 当返回一个Iterator对象时，就有一个指针游标指向集合第一个元素的前一个位置，当Iterator调用hasNext()后，判断指针指向的位置的下一个位置是否有元素，如果有则进入循环，调用next()指针下移，返回下移后指向的位置上的元素

Iterator接口的remove()方法：可以在遍历的时候，删除集合元素。此方法不同于集合调用remove()

- Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove()
- 如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException

![image-20230322082222943](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322082222943.png)



使用foreach循环遍历集合元素

- Java5.0提供了foreach循环迭代访问Collection集合和数组
- 遍历操作不需获取Collection或数组的长度，无需使用索引访问元素
- 遍历集合的底层调用Iterator完成操作
- foreach还可以用来遍历数组

```java
public void test3(){
        Collection coll = new ArrayList();
        coll.add(123);
        coll.add(456);
        coll.add(new Person("Jerry",20));
        coll.add(new String("Tom"));
        coll.add(false);

        //删除集合中"Tom"
        Iterator iterator = coll.iterator();
        while (iterator.hasNext()){
            Object obj = iterator.next();
            if("Tom".equals(obj)){
                iterator.remove();
            }
        }
        //遍历集合
        iterator = coll.iterator();
        while (iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
```



### 2.4、Collection的子接口之一：List接口

#### 2.4.1、概述

鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组。

List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。

List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。

JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector

- ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储
- LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储
- Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储



#### 2.4.2、List接口方法

List除了从Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法：

- void add(int index,Object ele)：在index位置插入ele元素，index后面的元素后移
- boolean addAll(int index,Collection eles)：从index位置开始将eles中的所有元素添加进来
- Object get(int index)：获取指定index位置的元素
- int indexOf(Object obj)：返回obj在集合中首次出现的位置，如果不存在，返回-1
- int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置
- Object remove(int index)：移除指定index位置的元素，并返回此元素（重载方法）
- Object set(int index,Object ele)：设置指定index位置的元素为ele，返回被替换掉的元素
- List subList(int fromIndex,int toIndex)：返回从fromIndex到toIndex位置的子集合，左闭右开的子集合



#### 2.4.3、总结常用方法

- 增：add(Object obj)
- 删：remove(int index) / remove(Object obj)
- 改：set(int index,Object ele)
- 查：get(int index)
- 插：add(int index,Object ele)
- 长度：size()
- 遍历：Iterator迭代器方法、增强for循环、普通循环





#### 2.4.4、List实现类之一：ArrayList

##### 1、概述

ArrayList是List接口的典型实现类、主要实现类

本质上，ArrayList是对象引用的一个“变长”数组

ArrayList在JDK1.8之前与之后的实现区别？

- JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组
- JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个初始容量为10的数组

Arrays.asList(...)方法返回List集合，既不是ArrayList实例，也不是Vector实例，Arrays.asList(...)返回值是一个固定长度的List集合



##### 2、ArrayList源码分析：jdk7

```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * Shared empty array instance used for empty instances.
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

    /**
     * Shared empty array instance used for default sized empty instances. We
     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when
     * first element is added.
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     * The array buffer into which the elements of the ArrayList are stored.
     * The capacity of the ArrayList is the length of this array buffer. Any
     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
     * will be expanded to DEFAULT_CAPACITY when the first element is added.
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * The size of the ArrayList (the number of elements it contains).
     *
     * @serial
     */
    private int size;
}


ArrayList list = new ArrayList()；// 底层创建了长度是10的Object[]数组elementData
list.add(123);//elementData[0] = new Integer(123)
...
list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容，默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中
```

结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)，减少底层频繁扩容数组，提高效率



##### 3、ArrayList源码分析：jdk8

```java
ArrayList list = new ArrayList();//底层Object[]数组elementData初始化为{}，并没有创建长度为10的数组
list.add(123);//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData[0]
... 后续添加和扩容操作与jdk7一样
```

结论：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存 



#### 2.4.5、List实现类之二：LinkedList

对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高

新增方法：

- void addFirst(Object obj)
- void addLast(Object obj)
- Object getFirst()
- Object getLast()
- Object removeFirst()
- Object removeLast()

LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量

- prev变量记录前一个元素的位置
- next变量记录下一个元素的位置

```java
LinkedList list = new LinkedList();内部声明了Node类型的first属性和last属性，默认值为null
list.add(123);//将123封装到Node中，创建了Node对象
其中，Node定义为：体现了LinkedList的双向链表的说法
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

​	

#### 2.4.6、List实现类之三：Vector

Vector是一个古老的集合，JDK1.0就存在了。大多数操作与ArrayList相同，区别之处在于Vector线程是安全的

在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用

Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组在扩容方面，默认扩容为原来数组长度的2倍



### 2.5、Collection子接口之二：Set接口

#### 2.5.1、概述

Set接口是Collection的子接口，Set接口没有提供额外的方法

Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败

Set判断两个对象是否相同不是使用 ==运算符，而是根据equals方法

Set存储数据的特点：无序，不可重复



#### 2.5.2、Set接口的实现类

HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值

LinkedHashSet：作为HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet

TreeSet：可以按照添加对象的指定属性，进行排序



#### 2.5.3、理解Set无序和不可重复

##### 1、以HashSet为例说明

无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的

不可重复性：保证添加的元素按照equals()判断时不能返回true，即相同的元素只能添加一个 



##### 2、Set中添加元素的过程

以HashSet为例，底层创建数组的时机和ArrayList一样，长度为16

向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断数组此位置上是否已经有元素：

- 如果此位置上没有其他元素，则元素a添加成功(情况1)


- 如果此位置上有其他元素b(或以链表形式存在的多个元素)，则比较元素a与元素b的hash值

  - 如果hash值不相同，则元素a添加成功(情况2)


  - 如果hash值相同，进而需要调用元素a所在类的equals()方法，如果元素b以链表形式存在的多个元素，则遍历比较

    - equals()返回true，元素a添加失败
    - equals()返回false，元素a添加成功(情况3)

对于添加成功的情况而言：元素a与已经存在指定索引位置上的数据以链表的方式存储

- jdk7中：元素a放到数组中，指向原来的元素
- jdk8中：原来的元素在数组中，指向元素a

![image-20230322090059733](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322090059733.png)



#### 2.5.4、Set实现类之一：HashSet

##### 1、介绍与特点

HashSet是Set接口的典型实现，大多数时候使用Set集合时都是用这个实现类 

HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能

HashSet具有以下特点：

- 不能保证元素的排列顺序
- HashSet是线程不安全的
- 集合元素可以是null
- 底层是数组+链表
- HashSet的底层是HashMap

HashSet集合判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals方法的返回值也相等

对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码(哈希值)”

添加元素，元素会被添加在Map的Key位置，而Value值怎是一个Object对象

```java
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable {
    static final long serialVersionUID = -5024744406713321676L;

    private transient HashMap<E,Object> map;

    // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();

    /**
     * Constructs a new, empty set; the backing <tt>HashMap</tt> instance has
     * default initial capacity (16) and load factor (0.75).
     */
    public HashSet() {
        map = new HashMap<>();
    }
    
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
}
```



##### 2、向HashSet中添加元素的过程

当向HashSet集合中存入（移除）一个元素时，HashSet会先调用该对象的hashCode()方法来得到该对象的hashCode值，通过某种散列函数决定该对象在HashSet底层数组中的存储位置（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素越是散列分布，该散列函数设计的越好）

如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续链接

向Set中添加的数据，其所在类一定要重写hashCode()和equals()，且尽可能保持一致性

如果两个元素的equals()方法返回true，但它们的hashCode()返回值不相等，HashSet将会把它们存储到不同的位置，但依然可以添加成功



##### 3、重写equals()方法的原则

当一个类有自己特有的“逻辑相等”概念，当改写equals()的时候， 总是要改写hashCode()，根据一个类的equals方法(改写后)，两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。

因此，违反了“相等的对象必须具有相等的散列码”。

结论：复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。



#### 2.5.5、HashSet的实现类：LinkedHashSet

LinkedHashSet是HashSet的子类，遍历其内部数据时，可以按照添加的顺序遍历 

LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的

LinkedHashSet插入性能略低于HashSet，但在迭代访问Set里的全部元素时有很好的性能

LinkedHashSet不允许集合元素重复

LinkedHashSet底层结构：与HashSet相似，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据的地址

- 优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet

LinkedHashSet底层是LinkedHashMap



#### 2.5.6、Set实现类之三：TreeSe

##### 1、TreeSet特点

TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态（从小到大）

向TreeSet中添加的数据，要求是相同类的对象

可以按照添加对象的指定属性，进行排序

TreeSet底层使用红黑树结构存储数据

有序，查询速度比List块



##### 2、TreeSet两种排序方式

自然排序(Comparable接口)和定制排序(Comparator接口)。默认情况下TreeSet采用自然排序

自然排序：

- 自然排序中，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()。TreeSet会调用集合元素的comparaTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列
- 如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口
  - 实现Comparable的类必须实现compareTo(Object obj)方法，两个对象即通过compareTo(Object obj)方法的返回值来比较大小
  - 向TreeSet中添加元素时，只有第一个元素无需比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较
  - 因为只有相同类的两个实例才会比较大小，所以向TreeSet中添加的应该是同一个类的对象
  - 对于TreeSet集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过compareTo(Objectobj)方法比较返回值
  - 当需要把一个对象放入TreeSet中，重写该对象对应的equals()方法时，应保证该方法与compareTo(Object obj)方法有一致的结果：如果两个对象通过equals()方法比较返回true，则通过compareTo(Object obj)方法比较应返回0，否则，让人难以理解
  - Comparable的典型实现
    - BigDecimal、BigInteger以及所有的数值型对应的包装类：按它们对应的数值大小进行比较
    - Character：按字符的Unicode值来比较
    - Boolean：true对应的包装类实例大于false对应的包装类实例
    - String：按字符串中字符的Unicode值进行比较
    - Date、Time：后边的时间、日期比前面的时间、日期大

```java
//按照姓名从大到小排列,年龄从小到大排列
    @Override
    public int compareTo(Object o) {
        if(o instanceof User){
            User user = (User)o;
//            return -this.name.compareTo(user.name);
            int compare = -this.name.compareTo(user.name);
            if(compare != 0){
                return compare;
            }else{
                return Integer.compare(this.age,user.age);
            }
        }else{
            throw new RuntimeException("输入的类型不匹配");
        }
    }
```



定制排序：

- 定制排序中，比较两个对象是否相同的标准为：compare()返回0，不再是equals()
- TreeSet的自然排序要求元素所属的类实现Compareble接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其他属性大小进行排序，则考虑使用定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法
- 利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2如果返回0，表示相等；返回负整数，表示o1小于o2
- 要实现定制排序，需要将实现Compaator接口的实例作为形参传递给TreeSet的构造器
- 此时，仍然只能向TreeSet中添加相同类型的对象，否则发生ClassCastException异常
- 使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0

```java
public void test2(){
        Comparator com = new Comparator() {
            //按照年龄从小到大排列
            @Override
            public int compare(Object o1, Object o2) {
                if(o1 instanceof User && o2 instanceof User){
                    User u1 = (User)o1;
                    User u2 = (User)o2;
                    return Integer.compare(u1.getAge(),u2.getAge());
                }else{
                    throw new RuntimeException("输入的数据类型不匹配");
                }
            }
        };

        TreeSet set = new TreeSet(com);
        set.add(new User("Tom",12));
        set.add(new User("Jerry",32));
        set.add(new User("Jim",2));
        set.add(new User("Mike",65));
        set.add(new User("Mary",33));
        set.add(new User("Jack",33));
        set.add(new User("Jack",56));

        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
```

![image-20230322093429433](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322093429433.png)



> 注：
>
> 在List内去除重复数字值，要求尽量简单。
>
> ```java
> public static List duplicateList(List list) {
>     HashSet set = new HashSet();
>     set.addAll(list);
>     return new ArrayList(set);
> }
> public static void main(String[] args) {
>     List list = new ArrayList() ;
>     list.add(new Integer(1));
>     list.add(new Integer(2));
>     list.add(new Integer(2));
>     list.add(new Integer(4));
>     list.add(new Integer(4));
>     List list2 = duplicateList(list);
>     for (object integer : list2) {
>        System.out.println(integer);
>     }
> }
> ```
>
> ```java
> public void test3(){
>         HashSet set = new HashSet();
>         Person p1 = new Person(1001,"AA");//Person中重写了equals()和hashCode()
>         Person p2 = new Person(1002,"BB");
> 
>         set.add(p1);
>         set.add(p2);
>         System.out.println(set);
> 
>         p1.name = "CC";
>         set.remove(p1); //false 因为remove方法调用了对象的hash方法，计算了对象的hash值，这时p1的hash值已经改变，在集合中找不到p1
>         System.out.println(set);//两个对象BB,CC
>         set.add(new Person(1001,"CC"));
>         System.out.println(set);//三个对象BB，CC，CC 因为CC之前的p1存储的位置是AA的
>         set.add(new Person(1001,"AA"));// 可以链接在存储在AA位置的CC上
>         System.out.println(set);
>     }
> ```









![image-20230322093443096](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230322093443096.png)













































