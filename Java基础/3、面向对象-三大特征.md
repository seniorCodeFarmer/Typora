## 1、封装与隐藏

### 1.1、概述

为什么需要封装？封装的作用与含义

- 我要用洗衣机，只需要按一下开关和洗涤模式就可以了，有必要了解洗衣机内部的结构吗？有必要碰电动机吗？
- 我们程序设计追求“高内聚，低耦合”
  - 高内聚：类的内部数据操作细节自己完成，不允许外部干涉；
  - 低耦合：仅对外暴露少量的方法用于使用
- 隐藏类内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性，通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。将一些细节隐藏在类的内部，对外提供公共的操作（赋值和获取）数据的入口，在数据处理（赋值的操作）中加入控制。



### 1.2、体现

- 我们将类的属性xxx私有化(private)的同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值。
- 权限修饰符：
  - Java规定的4种权限（从小到大排列）：private(类内部)、缺省(同一个包)、protected(不同包的子类) 、public(同一个工程)。
  - 4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类
  - 修饰类的话，只能使用：缺省、public

- 总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。

![image-20230803202333316](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230803202333316.png)



### 1.3、目的

- 隐藏一个类中不需要对外提供的实现细节；
- 使用者只能通过事先制定好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；
- 便于修改，增强代码的可维护性；



## 2、继承性

### 2.1、概述

- 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可
- 此处的多个类称为子类（派生类），单独的这个类称为父类（基类或超类）
- 开闭原则
  - 开：对扩展开放
  - 闭：对修改封闭
- 使用场景
  - 具有 is a 的关系，逻辑上一定要通畅，子类is a 父类
  - 一定是多了类中的重复属性或重复方法



### 2.2、作用

- 继承的出现减少了代码冗余，提高了代码的复用性。
- 继承的出现，更有利于功能的扩展
- 继承的出现让类与类之间产生了关系，提供了多态的前提



### 2.3、体现

子类继承了父类，就继承了父类的方法和属性。

- 特别的，父类中声明为private的属性和方法，子类没有继承，但仍然认为获取了父类中私有的结构。只是因为封装性的影响，使得子类不能直接调用父类私有的结构而已。
- Java官方文档的解释：子类不能继承父类的私有属性，但是如果子类中公有的方法影响到了父类私有属性，那么私有属性是能够被子类使用的。
- 实例化子类时，在内存中有一个父类的私有变量已经放到了内存中。这一点通过子类访问父类的public或protect方法可以访问到父类的私有变量。

子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的扩展。



### 2.4、规则

- 子类不能直接访问父类中私有的(private)的成员变量和方法，需要使用get和set方法
- Java中类是单继承的：一个类只能有一个父类，一个类可以被多个子类继承
- 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类
- 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法
- 如果没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类
- 所有java类（除java.lang.Object）都直接或间接的继承于java.lang.Object类，意味着，所有的java类具有java.lang.Object类声明的功能
- 父类private的结构没有被子类继承，不能直接调用，但是可以间接使用
- 父类的构造方法没有被子类继承，所以Dog dog = new Pet()不成立
- default修饰符的在不同包中的子类不可以被继承

```java
public class Extend {
    public static void main(String[] args) {
        Father father = new Father();
        father.setAge(12);
        father.setName("张三");
        Son son = new Son();
        son.setAge(21);
        son.setName("张五");
        System.out.println(father.getAge());
        System.out.println(son.getAge());
        System.out.println(son.getName());
    }
}

class Father {
    private String name;

    private int age;

    public Father() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void eat() {
        System.out.println("吃饭");
    }

    private void test() {

    }
}

class Son extends Father {
    public Son() {
    }

    public void play() {

    }
}
```

输出：

```
12
21
张五
```

- 这证明父类私有的属性子类中也有一份，只是子类不能直接调用，可以通过公开的方法来影响。



### 2.5、方法的重写

- 定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。
- 重写的规定，方法的声明：

~~~java
权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{
     //方法体
}
~~~

约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法

- 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同

- 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符（因为这是扩展，不是缩小）

- - 特殊情况：子类不能重写父类中声明为private权限的方法

返回值类型：

- 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
- 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类（这也算是扩展）
- 父类被重写的方法的返回值类型是基本数据类型（比如：double），则子类重写的方法的返回值类型必须是相同的基本数据类型（必须也是double）
- 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型

> 注：
>
> - 子类与父类中同名同参数的方法必须同时声明为非static的（即为重写），或者同时声明为static（不是重写）。因为static方法是属于类的，子类无法覆盖父类的static方法。



### 2.6、四种权限修饰符

![image-20230803205857744](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230803205857744.png)

![image-20230803205910059](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230803205910059.png)

在合适的场景下使用合适的修饰符：

- private：一般配合封装使用
- protected：配合继承使用
- 默认（default）：组件(平台)开发，



### 2.7、子类对象实例化的全过程

#### 2.7.1、从结果上来看：（继承性）

- 子类继承父类以后，就获取了父类中声明的属性或方法。
- 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。

#### 2.7.2、从过程上来看：

- 通过子类的构造器创建子类对象时，一定会直接或间接默认的调用其父类的无参构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。
- 明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。（从JVM底层来讲，并不是调用了构造器就创建了对象，还必须要有new指令）

> 注：
>
> - 设计类时，最好是子类无参构造器调用父类无参构造器，子类有参构造器调用父类有参构造器。



## 3、多态性

- 多态是同一个行为具有多个不同表现形式或形态的能力。
- 多态就是同一个接口，使用不同的实例而执行不同操作。
- 可以将多态理解为一个事物的多种形态。

### 3.1、何为多态性

- 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用) —— 向上转型（upcasting）
- 可以直接应用在抽象类和接口上（匿名内部类是多态性的一种体现，因为匿名内部类必须实现抽象类或接口）
- 将子类相同的方法，提取到父类，子类重写父类方法，使用多态调用时，通过父类类型可以调用父类的方法也可以调用子类的方法（虚拟方法调用）
- Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。若编译时类型和运行时类型不一致，就出现了对象的多态性。



### 3.2、多态的使用：虚拟方法调用

- 具有继承关系，并且一定要子类重写了父类的方法
- 子类对象赋值给父类或者父类的引用指向子类（里氏替换原则）；父类调用方法，最终透明的调用子类的方法（虚拟方法调用）
- 多态情况下：“看左边”：看的是父类的引用（父类中不具备子类特有的方法）；“看右边”：看的是子类的对象）（实际运行的是子类重写父类的方法）
- 总结：编译，看左边；运行，看右边
- 编译时，father为父类类型的实例，只能调用父类中的属性和方法，不能调用子类所特有的属性和方法。但是在新建对象时，父类和子类中的属性和方法都在内存中加载了，由于声明的是父类类型，导致编译时，只能调用父类中声明的属性和方法不能调用子类中的特有的属性和方法。
- 调用公共的方法和调用子类特有的方法
  - 调用公共的方法使用多态
  - 如何在编译器能调用子类特有的属性和方法：使用强制类型转换符 —— 向下转型
  - 使用强转时，可能出现ClassCastException的异常
  - 如果需要向下转型，必须保证是转型成自己的子类类型
  - 向下转型的前提：先使用了多态，即父类的引用指向子类的对象，然后可转型为自己的子类类型。

~~~java
 Son son = (Son)father;
~~~

![image-20230804212420808](https://zcw-typora.oss-cn-nanjing.aliyuncs.com/image-20230804212420808.png)



### 3.3、对象的多态性，只适用于方法，不适用与属性（编译和运行都看左边）

- 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里同名的方法，系统将不可能把父类里的方法转移到子类中。
- 对于实例变量则不存才这样的现象，即使子类里定义了与父类完全先相同的实例变量，这个实例变量依然不可能覆盖父类中的实例变量。
- 父类中定义的实例变量，编译运行都看左边。
- 方法动态绑定在对象上，属性静态的绑定在类型上。



### 3.4、instanceof操作符

- x instanceof A：检验对象x是否为类A的实例，返回值为 boolean 型。

- 为了避免出现 ClassCastException 的异常，我们在向下转型之前，先进行 instanceof 的判断，一旦返回 true，就进行向下转型， 返回false就不进行向下转型。 

- - 要求x所属的类与类A必须是子类和父类的关系，否则编译错误。
  - 如果对象x属于类A的子类B，x instanceof A 值也为true。



### 3.5、虚拟方法调用（多态情况下）

- 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
- 动态绑定：编译时为父类类型，而方法的调用是在运行时确定的



### 3.6、方法的重载和重写的区别

- 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。
- 重写，是指在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。





















